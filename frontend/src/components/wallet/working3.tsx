    // No. me =  xpub 03486fc70e31b45fb24094e714ef2f2fed9d86cf9f2158413be380280fdd3f2416 /  
    // xpri / 6811543cdaae96cc602c2ed5efe517bf86cecdb0abbe678eb957b86bf8d3ff13
    // muCRZXdunSqaKv5REC37Ahf6ZUAK2yqKes
    // Working3.tsx file is development of conversations ID's 
    // WALLET4 IS THE DEVELOPMENT FILE


   // EVE TEST 
   // sHARED ECDH 1st 2nd 3rd 4th 5th 
   // No.1 7/July  cdeaeceea52dad5af09ff2cc04a667be4f86a966ade187ebc3b83b6795691391
   // No.2 7/July c55aff6a586b95961107d62fe23ce0e769f974dcbd3fd37ccb9d56d2385780d0
   // No.3 7/July bdfae5d6121c0b07967c4aa61b656f242cdc3ccbbfafd63b4b2f606e761786eb
   // No.4 7/July 0b3b8b43b1d7d1fa1e8315db4e4567717eec1871c33c8fcebc13f71fc4dfdd9b
   // No.5 7/July f4a1d5af9a9165947d517b07ca4caf5a0b20c92029fb3ed46f6d576de3a212be

   // eve type 42 
   // eve  2c526af378445c505751dda8b9d991f49cbcaf123fcfba8c3d6dd4757e9cbada
    // eve2 17b7fb3f0eed0ad01117cf45666be3ba40afdcd59c0b781c805c2c175e22be14
    // from eve back to me text message
    // tester1 back to me text message     509fc2c232a2ebcdba6fb05e45fb41e8132ff98eb321e8a1f84761d858fbaa4d


    // I am current logged into c756944a8e5bd6685f4ff6f2a03b560d90692ad66e91b48c4319be3e3bd04b0d  (logged as Eve) 
    // and the messageas are showing up 
    // From: Eve Testing08/07/2025, 13:27:59  2nd message from Eve Testing 

// my xpub       03486fc70e31b45fb24094e714ef2f2fed9d86cf9f2158413be380280fdd3f2416
    // another attempt at the decoding = my pri = 6811543cdaae96cc602c2ed5efe517bf86cecdb0abbe678eb957b86bf8d3ff13
    // my message =  Jesus christ is the king of kings and the lord of lords.
    // my contact xpub key = 02f46878d8dd99d12a3f61a3cb4436b33f854d051ed04b35afa8e14a71f01b1ea2
    // ECDH Shared Secret: 038f07a6b89a3345729e159ba0e92dc1b67bef1a744adeea507f9c7ebb452d93c8
// txid = 416792aef25f91f7c09c13c1462c653ad65aae6faa02d3dcb3a7220c01332cb3
// encrypted raw data =    a70c705c2e4fba25d4aaed3671caf82d71406e57489626d36376e4b8c027c1ca3af0a3d213a10b6d9aad94c576cd7c9baacdc1fd386c45bc6ef622943d61c30aec4f00713ceee49f85e22a60
// 1933
// me to me shared secrete =  033aaa580e1f2b086ecccd45ee1767b805f270e7850ddc799cf73f3331e9da3f84
{
    "txid": "0bce84c52add3f4206d7d8eda460534ba33e1286bc56aba34fcb75e95802ad4e",
    "hash": "0bce84c52add3f4206d7d8eda460534ba33e1286bc56aba34fcb75e95802ad4e",
    "size": 320,
    "version": 1,
    "locktime": 0,
    "vin": [
        {
            "n": 0,
            "txid": "2c526af378445c505751dda8b9d991f49cbcaf123fcfba8c3d6dd4757e9cbada",
            "vout": 2,
            "scriptSig": {
                "asm": "304402207878e4307a38654eb460c6871399d03dd84ea0548bd7c5e04864c96609689a3302205103824be1cf5b903b3e90757e7164977a1c15e5bea953842ec555e846abe0e041 03486fc70e31b45fb24094e714ef2f2fed9d86cf9f2158413be380280fdd3f2416",
                "hex": "47304402207878e4307a38654eb460c6871399d03dd84ea0548bd7c5e04864c96609689a3302205103824be1cf5b903b3e90757e7164977a1c15e5bea953842ec555e846abe0e0412103486fc70e31b45fb24094e714ef2f2fed9d86cf9f2158413be380280fdd3f2416",
                "isTruncated": false
            },
            "sequence": 4294967295,
            "voutDetails": {
                "value": 0.00076312,
                "n": 2,
                "scriptPubKey": {
                    "asm": "OP_DUP OP_HASH160 96109e6f50f89ba8dca4f79b58e8428fa63021e3 OP_EQUALVERIFY OP_CHECKSIG",
                    "hex": "76a91496109e6f50f89ba8dca4f79b58e8428fa63021e388ac",
                    "reqSigs": 1,
                    "type": "pubkeyhash",
                    "addresses": [
                        "muCRZXdunSqaKv5REC37Ahf6ZUAK2yqKes"
                    ],
                    "isTruncated": false
                },
                "scripthash": "4906884ae1623dd8a9570af55c68f7f78828329980e9739f23c2d48be8cdb273"
            }
        }
    ],
    "vout": [
        {
            "value": 0,
            "n": 0,
            "scriptPubKey": {
                "asm": "0 OP_RETURN 19337b1d843a46e19673f31770214ed648b13757e0fb715fbef86738132242c40c934039bf222c1d125f70666f6607869ee558b6289c5c36724258f13ff672f7b395690b7a44331559fbe735328092f0c0b6",
                "hex": "006a4c5219337b1d843a46e19673f31770214ed648b13757e0fb715fbef86738132242c40c934039bf222c1d125f70666f6607869ee558b6289c5c36724258f13ff672f7b395690b7a44331559fbe735328092f0c0b6",
                "type": "nulldata",
                "opReturn": {
                    "type": "OP_RETURN"
                },
                "isTruncated": false
            },
            "scripthash": "bdad639722025790633dfe9a5ee77e6bcd8e5222335606eac79c1db8515d15b2"
        },
        {
            "value": 0.00001,
            "n": 1,
            "scriptPubKey": {
                "asm": "OP_DUP OP_HASH160 5abb2bb6f383ca1687bacb0a05820be55ea38701 OP_EQUALVERIFY OP_CHECKSIG",
                "hex": "76a9145abb2bb6f383ca1687bacb0a05820be55ea3870188ac",
                "reqSigs": 1,
                "type": "pubkeyhash",
                "addresses": [
                    "monhLAt6nud2Z7BXjpR5sYHpavupvkW9BN"
                ],
                "isTruncated": false
            },
            "scripthash": "92427f920dfd1437a1c30ab69d27ecdf506f896d7097d768f984ed3c1c711123"
        },
        {
            "value": 0.00075311,
            "n": 2,
            "scriptPubKey": {
                "asm": "OP_DUP OP_HASH160 96109e6f50f89ba8dca4f79b58e8428fa63021e3 OP_EQUALVERIFY OP_CHECKSIG",
                "hex": "76a91496109e6f50f89ba8dca4f79b58e8428fa63021e388ac",
                "reqSigs": 1,
                "type": "pubkeyhash",
                "addresses": [
                    "muCRZXdunSqaKv5REC37Ahf6ZUAK2yqKes"
                ],
                "isTruncated": false
            },
            "scripthash": "4906884ae1623dd8a9570af55c68f7f78828329980e9739f23c2d48be8cdb273"
        }
    ],
    "blockhash": "000000001dad750fb3a40f0b2c7aa7c5834d324adaa0997ddc45b2ced7eb4afa",
    "confirmations": 35,
    "time": 1751981425,
    "blocktime": 1751981425,
    "blockheight": 1683062,
    "vincount": 1,
    "voutcount": 3,
    "vinvalue": 0.00076312,
    "voutvalue": 0.00076311
}




































///////////////////////////////////////

<div className="mt-4 p-4 bg-gray-700 rounded-lg border border-gray-600">
              <h3 className="text-lg font-semibold mb-3 text-white">Send Encrypted Message</h3>
              
              <div className="space-y-3">
                <textarea
                  value={newConversationMessage}
                  onChange={(e) => setNewConversationMessage(e.target.value)}
                  placeholder="Type your message here..."
                  rows={3}
                  className="w-full px-4 py-2 bg-gray-800 border border-gray-600 rounded-lg text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-cyan-500"
                  disabled={!keyData.privateKey || sendingMessage}
                />
                
                <div className="flex items-center justify-between">
                  <button
                    onClick={sendMessageToBlockchain}
                    disabled={!keyData.privateKey || !newConversationMessage.trim() || sendingMessage}
                    className="bg-cyan-500 hover:bg-cyan-600 text-white font-medium py-2 px-6 rounded-lg transition-colors disabled:bg-gray-600 disabled:cursor-not-allowed"
                  >
                    {sendingMessage ? 'Sending...' : 'Send to Blockchain'}
                  </button>
                  
                  {transactionStatus && (
                    <p className={`text-sm ${
                      transactionStatus.includes('Error') ? 'text-red-400' : 
                      transactionStatus.includes('Demo') ? 'text-yellow-400' : 
                      'text-green-400'
                    }`}>
                      {transactionStatus}
                    </p>
                  )}
                </div>
              </div>
              
              <div className="mt-3 p-3 bg-gray-800 rounded border border-gray-600">
                <div className="mb-2 flex items-center justify-between">
                  <p className="text-xs text-gray-400">
                    <span className="font-medium text-cyan-400">How it works:</span> Your message will be encrypted using 
                    {useType42Encryption ? ' Type-42 Advanced encryption with forward secrecy' : ' standard ECDH'} 
                    with {selectedConversationContact?.name || 'the selected contact'}'s public key.
                  </p>
                  <button
                    onClick={() => setUseType42Encryption(!useType42Encryption)}
                    className={`px-3 py-1 rounded text-xs font-medium transition-colors ${
                      useType42Encryption 
                        ? 'bg-purple-600 hover:bg-purple-700 text-white' 
                        : 'bg-gray-600 hover:bg-gray-500 text-white'
                    }`}
                  >
                    {useType42Encryption ? 'Type-42 ‚úì' : 'Standard'}
                  </button>
                </div>
                {useType42Encryption && (
                  <div className="text-xs text-purple-400 mt-1">
                    <p>üîê Type-42 Advanced Features:</p>
                    <ul className="ml-4 mt-1 space-y-1">
                      <li>‚Ä¢ Daily rotating conversation keys</li>
                      <li>‚Ä¢ Unique key for each message (forward secrecy)</li>
                      <li>‚Ä¢ Multi-layer encryption for maximum security</li>
                      <li>‚Ä¢ Message metadata stored on-chain</li>
                    </ul>
                  </div>
                )}
                {network === 'testnet' && (
                  <p className="text-xs text-green-400 mt-2">
                    ‚úì Testnet Mode: Real transactions will be broadcast to the BSV testnet.
                  </p>
                )}
                {balance.confirmed < 2000 && (
                  <p className="text-xs text-yellow-400 mt-2">
                    ‚ö†Ô∏è Low Balance: You need at least 2000 satoshis to send a message. Current: {balance.confirmed} sats
                  </p>
                )}
              </div>
            </div>
          </div>
        )}







19337b1d843a46e19673f31770214ed648b13757e0fb715fbef86738132242c40c934039bf222c1d125f70666f6607869ee558b6289c5c36724258f13ff672f7b395690b7a44331559fbe735328092f0c0b6



        {
    "txid": "0bce84c52add3f4206d7d8eda460534ba33e1286bc56aba34fcb75e95802ad4e",
    "hash": "0bce84c52add3f4206d7d8eda460534ba33e1286bc56aba34fcb75e95802ad4e",
    "size": 320,
    "version": 1,
    "locktime": 0,
    "vin": [
        {
            "n": 0,
            "txid": "2c526af378445c505751dda8b9d991f49cbcaf123fcfba8c3d6dd4757e9cbada",
            "vout": 2,
            "scriptSig": {
                "asm": "304402207878e4307a38654eb460c6871399d03dd84ea0548bd7c5e04864c96609689a3302205103824be1cf5b903b3e90757e7164977a1c15e5bea953842ec555e846abe0e041 03486fc70e31b45fb24094e714ef2f2fed9d86cf9f2158413be380280fdd3f2416",
                "hex": "47304402207878e4307a38654eb460c6871399d03dd84ea0548bd7c5e04864c96609689a3302205103824be1cf5b903b3e90757e7164977a1c15e5bea953842ec555e846abe0e0412103486fc70e31b45fb24094e714ef2f2fed9d86cf9f2158413be380280fdd3f2416",
                "isTruncated": false
            },
            "sequence": 4294967295,
            "voutDetails": {
                "value": 0.00076312,
                "n": 2,
                "scriptPubKey": {
                    "asm": "OP_DUP OP_HASH160 96109e6f50f89ba8dca4f79b58e8428fa63021e3 OP_EQUALVERIFY OP_CHECKSIG",
                    "hex": "76a91496109e6f50f89ba8dca4f79b58e8428fa63021e388ac",
                    "reqSigs": 1,
                    "type": "pubkeyhash",
                    "addresses": [
                        "muCRZXdunSqaKv5REC37Ahf6ZUAK2yqKes"
                    ],
                    "isTruncated": false
                },
                "scripthash": "4906884ae1623dd8a9570af55c68f7f78828329980e9739f23c2d48be8cdb273"
            }
        }
    ],
    "vout": [
        {
            "value": 0,
            "n": 0,
            "scriptPubKey": {
                "asm": "0 OP_RETURN 19337b1d843a46e19673f31770214ed648b13757e0fb715fbef86738132242c40c934039bf222c1d125f70666f6607869ee558b6289c5c36724258f13ff672f7b395690b7a44331559fbe735328092f0c0b6",
                "hex": "006a4c5219337b1d843a46e19673f31770214ed648b13757e0fb715fbef86738132242c40c934039bf222c1d125f70666f6607869ee558b6289c5c36724258f13ff672f7b395690b7a44331559fbe735328092f0c0b6",
                "type": "nulldata",
                "opReturn": {
                    "type": "OP_RETURN"
                },
                "isTruncated": false
            },
            "scripthash": "bdad639722025790633dfe9a5ee77e6bcd8e5222335606eac79c1db8515d15b2"
        },
        {
            "value": 0.00001,
            "n": 1,
            "scriptPubKey": {
                "asm": "OP_DUP OP_HASH160 5abb2bb6f383ca1687bacb0a05820be55ea38701 OP_EQUALVERIFY OP_CHECKSIG",
                "hex": "76a9145abb2bb6f383ca1687bacb0a05820be55ea3870188ac",
                "reqSigs": 1,
                "type": "pubkeyhash",
                "addresses": [
                    "monhLAt6nud2Z7BXjpR5sYHpavupvkW9BN"
                ],
                "isTruncated": false
            },
            "scripthash": "92427f920dfd1437a1c30ab69d27ecdf506f896d7097d768f984ed3c1c711123"
        },
        {
            "value": 0.00075311,
            "n": 2,
            "scriptPubKey": {
                "asm": "OP_DUP OP_HASH160 96109e6f50f89ba8dca4f79b58e8428fa63021e3 OP_EQUALVERIFY OP_CHECKSIG",
                "hex": "76a91496109e6f50f89ba8dca4f79b58e8428fa63021e388ac",
                "reqSigs": 1,
                "type": "pubkeyhash",
                "addresses": [
                    "muCRZXdunSqaKv5REC37Ahf6ZUAK2yqKes"
                ],
                "isTruncated": false
            },
            "scripthash": "4906884ae1623dd8a9570af55c68f7f78828329980e9739f23c2d48be8cdb273"
        }
    ],
    "blockhash": "000000001dad750fb3a40f0b2c7aa7c5834d324adaa0997ddc45b2ced7eb4afa",
    "confirmations": 14,
    "time": 1751981425,
    "blocktime": 1751981425,
    "blockheight": 1683062,
    "vincount": 1,
    "voutcount": 3,
    "vinvalue": 0.00076312,
    "voutvalue": 0.00076311
}


























































import { PrivateKey, PublicKey, Transaction, Script, Utils } from '@bsv/sdk';
import { UTXOManager, SimpleTestnetBroadcaster } from '../utils/blockchain';

// Buffer polyfill for browser environment
const Buffer = {
  from: (data: string | Uint8Array, encoding?: string): Uint8Array => {
    if (typeof data === 'string') {
      if (encoding === 'hex') {
        const bytes = new Uint8Array(data.length / 2);
        for (let i = 0; i < data.length; i += 2) {
          bytes[i / 2] = parseInt(data.substr(i, 2), 16);
        }
        return bytes;
      } else {
        // UTF-8 encoding
        const encoder = new TextEncoder();
        return encoder.encode(data);
      }
    }
    return new Uint8Array(data);
  },
  concat: (arrays: Uint8Array[]): Uint8Array => {
    const totalLength = arrays.reduce((sum, arr) => sum + arr.length, 0);
    const result = new Uint8Array(totalLength);
    let offset = 0;
    for (const arr of arrays) {
      result.set(arr, offset);
      offset += arr.length;
    }
    return result;
  }
};

interface ProfileData {
  username: string;
  title: string;
  mission: string;
  profileImage: string; // Base64 or IPFS hash
  backgroundImage: string; // Base64 or IPFS hash
}

interface ProfileToken {
  tokenId: string;
  owner: string;
  profileData: ProfileData;
  ipfsHashes?: {
    profile?: string;
    background?: string;
  };
  timestamp: number;
  version: number;
}

interface ProfileTokenResponse {
  success: boolean;
  txid?: string;
  tokenId?: string;
  error?: string;
}

export class ProfileTokenService {
  private network: 'mainnet' | 'testnet';
  private apiKey?: string;
  private ipfsGateway: string = 'https://gateway.pinata.cloud/ipfs/';
  private broadcaster: SimpleTestnetBroadcaster;

  constructor(network: 'mainnet' | 'testnet' = 'testnet', apiKey?: string) {
    this.network = network;
    this.apiKey = apiKey;
    this.broadcaster = new SimpleTestnetBroadcaster();
  }

  /**
   * Upload image to IPFS (using Pinata or similar service)
   */
  private async uploadToIPFS(imageData: string): Promise<string> {
    // If it's already an IPFS hash or URL, return as is
    if (imageData.startsWith('ipfs://') || imageData.startsWith('Qm')) {
      return imageData;
    }

    // If it's a regular URL, return as is
    if (imageData.startsWith('http://') || imageData.startsWith('https://')) {
      return imageData;
    }

    // For base64 images, upload to IPFS
    if (imageData.startsWith('data:image')) {
      try {
        // Convert base64 to blob
        const base64Data = imageData.split(',')[1];
        const byteCharacters = atob(base64Data);
        const byteNumbers = new Array(byteCharacters.length);
        
        for (let i = 0; i < byteCharacters.length; i++) {
          byteNumbers[i] = byteCharacters.charCodeAt(i);
        }
        
        const byteArray = new Uint8Array(byteNumbers);
        const blob = new Blob([byteArray], { type: 'image/jpeg' });

        // For now, since we don't have IPFS configured, return a placeholder
        // In production, uncomment the following:
        /*
        const formData = new FormData();
        formData.append('file', blob);

        const response = await fetch('https://api.pinata.cloud/pinning/pinFileToIPFS', {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${process.env.REACT_APP_PINATA_JWT}`
          },
          body: formData
        });

        if (!response.ok) {
          throw new Error('Failed to upload to IPFS');
        }

        const data = await response.json();
        return `ipfs://${data.IpfsHash}`;
        */
        
        // Placeholder for demo - return a shortened version
        return 'placeholder';
      } catch (error) {
        console.error('IPFS upload error:', error);
        return 'placeholder';
      }
    }

    return imageData;
  }

  /**
   * Create a profile token transaction
   */
  async createProfileToken(
    privateKey: PrivateKey,
    profileData: ProfileData,
    utxos: any[]
  ): Promise<ProfileTokenResponse> {
    try {
      // Log the incoming profile data
      console.log('Creating profile token with data:', profileData);
      
      const publicKey = privateKey.toPublicKey();
      const address = publicKey.toAddress(this.network).toString();
      
      // Generate unique token ID
      const tokenId = Date.now().toString();
      
      // Upload images to IPFS if they're base64
      const ipfsProfile = await this.uploadToIPFS(profileData.profileImage);
      const ipfsBackground = await this.uploadToIPFS(profileData.backgroundImage);
      
      // Create profile token data
      const profileToken: ProfileToken = {
        tokenId,
        owner: address,
        profileData: {
          username: profileData.username || '',
          title: profileData.title || '',
          mission: profileData.mission || '',
          profileImage: ipfsProfile,
          backgroundImage: ipfsBackground
        },
        ipfsHashes: {
          profile: ipfsProfile.replace('ipfs://', ''),
          background: ipfsBackground.replace('ipfs://', '')
        },
        timestamp: Date.now(),
        version: 1
      };

      // Log the token data before creating transaction
      console.log('Profile token object:', profileToken);

      // Create transaction
      const tx = new Transaction();
      
      // Add inputs from UTXOs
      let totalInput = 0;
      for (const utxo of utxos) {
        tx.addInput({
          txid: utxo.tx_hash,
          vout: utxo.tx_pos,
          satoshis: utxo.value,
          script: utxo.script ? Script.fromHex(utxo.script) : new Script()
        });
        totalInput += utxo.value;
      }

      // Calculate fees (2 sat/byte estimate)
      const estimatedSize = 250 + (utxos.length * 180) + 200; // rough estimate
      const fee = estimatedSize * 2;
      const changeAmount = totalInput - fee - 1000; // 1000 sats for token output

      if (changeAmount < 0) {
        throw new Error(`Insufficient funds. Need at least ${fee + 1000} satoshis`);
      }

      // Add OP_RETURN output with profile metadata FIRST
      const metadataScript = this.createMetadataScript(profileToken);
      tx.addOutput({
        satoshis: 0,
        script: metadataScript
      });

      // Add token output with minimal sats (using P2PKH to owner address)
      const tokenScript = this.createTokenScript(profileToken);
      tx.addOutput({
        satoshis: 1000,
        script: tokenScript
      });

      // Add change output if needed
      if (changeAmount > 546) { // dust limit
        tx.addOutput({
          address: address,
          satoshis: changeAmount
        });
      }

      // Sign all inputs
      for (let i = 0; i < utxos.length; i++) {
        try {
          const utxo = utxos[i];
          const script = utxo.script ? Script.fromHex(utxo.script) : Script.fromAddress(address);
          const satoshis = BigInt(utxo.value);
          
          const signature = tx.sign(privateKey, 'SIGHASH_ALL', i, script, satoshis);
          
          const unlockingScript = new Script()
            .writeBin(signature.toDER())
            .writeUInt8(0x41) // SIGHASH_ALL
            .writeBin(publicKey.toDER());
          
          tx.inputs[i].script = unlockingScript;
        } catch (signError) {
          console.error(`Error signing input ${i}:`, signError);
          throw new Error(`Failed to sign transaction input ${i}`);
        }
      }

      // Broadcast transaction
      const result = await this.broadcaster.broadcast(tx);
      
      if (result.status === 'success' && result.txid) {
        console.log('Profile token created successfully:', result.txid);
        return {
          success: true,
          txid: result.txid,
          tokenId: tokenId
        };
      } else {
        throw new Error(result.error || 'Broadcast failed');
      }

    } catch (error) {
      console.error('Profile token creation error:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error'
      };
    }
  }

  /**
   * Create token script (simplified version)
   */
  private createTokenScript(profileToken: ProfileToken): Script {
    try {
      // Create a simple P2PKH script for the token output
      // In a real implementation, this would be your actual token contract script
      const script = new Script();
      
      // For now, just create a standard output that can be spent by the owner
      const ownerAddress = profileToken.owner;
      const addressScript = Script.fromAddress(ownerAddress);
      
      return addressScript;
    } catch (error) {
      console.error('Error creating token script:', error);
      // Fallback to a simple script
      return new Script();
    }
  }

  /**
   * Create metadata script for OP_RETURN
   */
  private createMetadataScript(profileToken: ProfileToken): Script {
    try {
      console.log('Creating metadata script for:', profileToken);
      
      // Create a compact metadata format
      const metadata: any = {
        id: profileToken.tokenId,
        u: profileToken.profileData.username || '',
        t: profileToken.profileData.title || ''
      };

      // Always include mission if it exists
      if (profileToken.profileData.mission) {
        metadata.m = profileToken.profileData.mission.substring(0, 50); // Limit to 50 chars
      }

      // Add version
      metadata.v = profileToken.version;

      // Add IPFS hashes if images were uploaded
      if (profileToken.ipfsHashes?.profile && profileToken.ipfsHashes.profile !== 'placeholder') {
        metadata.pi = profileToken.ipfsHashes.profile.substring(0, 20); // First 20 chars
      }
      if (profileToken.ipfsHashes?.background && profileToken.ipfsHashes.background !== 'placeholder') {
        metadata.bi = profileToken.ipfsHashes.background.substring(0, 20); // First 20 chars
      }

      console.log('Metadata object:', metadata);

      // Create the data payload
      const prefix = Buffer.from('PROFILE', 'utf8');
      const dataBuffer = Buffer.from(JSON.stringify(metadata), 'utf8');
      
      // Combine prefix and data
      const fullData = Buffer.concat([prefix, dataBuffer]);
      
      console.log('Full payload size:', fullData.length, 'bytes');
      
      // Check size limit (OP_RETURN max is ~220 bytes)
      if (fullData.length > 220) {
        console.warn('Payload too large, creating minimal version');
        // If too large, create minimal version
        const minimalMetadata = {
          id: profileToken.tokenId,
          u: profileToken.profileData.username.substring(0, 15),
          t: profileToken.profileData.title.substring(0, 15),
          m: profileToken.profileData.mission.substring(0, 20),
          v: profileToken.version
        };
        const minimalData = Buffer.concat([
          Buffer.from('PROFILE', 'utf8'),
          Buffer.from(JSON.stringify(minimalMetadata), 'utf8')
        ]);
        
        const script = new Script();
        script.chunks = [
          { opcodenum: 106 }, // OP_RETURN = 106
          { buf: minimalData }
        ];
        return script;
      }
      
      // Create script with full data
      const script = new Script();
      script.chunks = [
        { opcodenum: 106 }, // OP_RETURN = 106
        { buf: fullData }
      ];
      
      console.log('Created script with', fullData.length, 'bytes of data');
      return script;
    } catch (error) {
      console.error('Error creating metadata script:', error);
      // Return a minimal OP_RETURN script
      const script = new Script();
      const fallbackData = Buffer.from(`PROFILE{"id":"${profileToken.tokenId}","error":"metadata"}`, 'utf8');
      script.chunks = [
        { opcodenum: 106 }, // OP_RETURN
        { buf: fallbackData }
      ];
      return script;
    }
  }

  /**
   * Retrieve profile token from blockchain
   */
  async retrieveProfileToken(txid: string): Promise<ProfileToken | null> {
    try {
      const baseUrl = this.network === 'testnet' 
        ? 'https://api.whatsonchain.com/v1/bsv/test'
        : 'https://api.whatsonchain.com/v1/bsv/main';
      
      const headers: any = {};
      if (this.apiKey) {
        headers['Authorization'] = `Bearer ${this.apiKey}`;
      }

      const response = await fetch(`${baseUrl}/tx/${txid}`, { headers });
      
      if (!response.ok) {
        throw new Error('Transaction not found');
      }
      
      const txData = await response.json();
      
      // Look for OP_RETURN output with profile data
      for (const output of txData.vout) {
        if (output.scriptPubKey && output.scriptPubKey.type === 'nulldata') {
          try {
            const scriptHex = output.scriptPubKey.hex;
            if (!scriptHex || typeof scriptHex !== 'string') {
              continue;
            }
            
            // Parse the hex data
            let dataHex = scriptHex;
            
            // Skip OP_0 (00) if present
            if (dataHex.startsWith('00')) {
              dataHex = dataHex.substring(2);
            }
            
            // Skip OP_RETURN (6a) and length byte
            if (dataHex.startsWith('6a')) {
              dataHex = dataHex.substring(2);
              // Skip the push data length byte
              if (dataHex.length >= 2) {
                const lengthByte = parseInt(dataHex.substring(0, 2), 16);
                dataHex = dataHex.substring(2);
              }
            }
            
            // Convert hex to string
            const dataBytes = Buffer.from(dataHex, 'hex');
            const decoder = new TextDecoder();
            const dataString = decoder.decode(dataBytes);
            
            // Check if it starts with PROFILE prefix
            if (dataString.startsWith('PROFILE')) {
              const jsonStr = dataString.substring(7); // Remove 'PROFILE' prefix
              
              try {
                const metadata = JSON.parse(jsonStr);
                
                // Get owner address from first non-OP_RETURN output
                let ownerAddress = '';
                for (const out of txData.vout) {
                  if (out.scriptPubKey?.type !== 'nulldata' && out.scriptPubKey?.addresses?.[0]) {
                    ownerAddress = out.scriptPubKey.addresses[0];
                    break;
                  }
                }
                
                // Reconstruct profile data
                const profileData: ProfileData = {
                  username: metadata.u || 'Unknown',
                  title: metadata.t || 'Unknown',
                  mission: metadata.m || 'No mission statement provided',
                  profileImage: metadata.pi ? `${this.ipfsGateway}${metadata.pi}` : '',
                  backgroundImage: metadata.bi ? `${this.ipfsGateway}${metadata.bi}` : ''
                };
                
                return {
                  tokenId: metadata.id || txid,
                  owner: ownerAddress,
                  profileData: profileData,
                  ipfsHashes: {
                    profile: metadata.pi || '',
                    background: metadata.bi || ''
                  },
                  timestamp: metadata.ts || Date.parse(txData.time || '') || Date.now(),
                  version: metadata.v || 1
                };
              } catch (parseError) {
                console.error('Failed to parse profile JSON:', parseError);
                console.log('JSON string:', jsonStr);
              }
            }
          } catch (error) {
            console.error('Failed to parse OP_RETURN output:', error);
          }
        }
      }
      
      return null;
    } catch (error) {
      console.error('Error retrieving profile token:', error);
      return null;
    }
  }

  /**
   * Fetch profile data from IPFS
   */
  private async fetchProfileFromIPFS(ipfsHashes: any): Promise<ProfileData> {
    // This is a placeholder - in production, you'd fetch from IPFS
    return {
      username: 'Retrieved User',
      title: 'Retrieved Title',
      mission: 'Retrieved Mission',
      profileImage: ipfsHashes.profile ? `${this.ipfsGateway}${ipfsHashes.profile}` : '',
      backgroundImage: ipfsHashes.background ? `${this.ipfsGateway}${ipfsHashes.background}` : ''
    };
  }

  /**
   * List all profile tokens for an address
   */
  async listProfileTokens(address: string): Promise<ProfileToken[]> {
    try {
      const baseUrl = this.network === 'testnet' 
        ? 'https://api.whatsonchain.com/v1/bsv/test'
        : 'https://api.whatsonchain.com/v1/bsv/main';
      
      const headers: any = {};
      if (this.apiKey) {
        headers['Authorization'] = `Bearer ${this.apiKey}`;
      }

      // Get transaction history
      const response = await fetch(`${baseUrl}/address/${address}/history`, { headers });
      
      if (!response.ok) {
        throw new Error('Failed to fetch address history');
      }
      
      const history = await response.json();
      const profileTokens: ProfileToken[] = [];
      
      // Check each transaction for profile tokens
      for (const tx of history) {
        const token = await this.retrieveProfileToken(tx.tx_hash);
        if (token && token.owner === address) {
          profileTokens.push(token);
        }
      }
      
      return profileTokens;
    } catch (error) {
      console.error('Error listing profile tokens:', error);
      return [];
    }
  }
}